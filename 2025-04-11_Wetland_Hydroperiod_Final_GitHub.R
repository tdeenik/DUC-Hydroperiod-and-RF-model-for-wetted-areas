# ECCC-DUC Wetland Hydrograph Analysis
# Author: Kristina Deenik, MSc, RPBio
# Date: 2025-04-11

#important discussion point: TRAINING DATA --> what year did I train the model on? How did I train it again? Where is the
#RF model code? Need to show work flow for thta and the Sentinel data.

# Description:
# This script analyzes wetted area over time for wetland polygons, generating hydrographs
# and identifying wetlands that show a statistically significant correlation with 
# mean annual precipitation (MAP).

# Libraries:
library(terra)           # For spatial raster data
library(sf)              # For vector spatial data
library(dplyr)           # For data manipulation
library(exactextractr)   # For efficient raster extraction
library(ggplot2)         # For plotting
library(lubridate)       # For handling date information
library(purrr)

# Summary of Methods:
# - Wetland polygons can be sourced externally or derived from high-resolution DEMs,
#   ideally LiDAR-based. In this analysis, wetland polygons were generated by intersecting
#   open water classifications with a stochastic depression model.
#
# - The stochastic depression raster represents the probability of a pixel being a depression.
#   Polygons were created from areas >95% probability and filtered to remove any smaller than 1000 m²
#   (approx. 3x3 Sentinel pixel area).
#
# - Random Forest classification outputs were used to identify pixels with >75% probability of being water.
#   A frequency raster ("summed_75") was created by summing these water probability rasters across dates,
#   highlighting areas that are consistently wet.
#
# - Polygons from the Stochastic Depression >95% layer were intersected with areas having non-zero values
#   in the "summed_75" raster, resulting in 77 polygons.
#
# - This output was merged with wetland shapefiles from DUC and ECCC for completeness,
#   and any polygons not overlapping with image scenes showing open water were removed,
#   resulting in a final set of 91 wetland polygons.
#
# - Note: Some years have more image scenes than others, which may visually skew x-axis timelines.
#   To ensure consistency with climate data, wetted area was summarized using one selected image
#   per year for the summer months (June–August).
#
# - The final selected cloud/smoke-free imagery dates per year were:
#   2019-08-09, 2020-07-14, 2021-07-09, 2022-08-08, 2023-07-09, 2024-07-08.
#   All dates were nearly within one month of eachother across different years

# Output:
# - Hydrographs showing percent wetted area over time for each wetland polygon.
# - Quantifies how variable each wetland's open water area is over time,
#   using the standard deviation (SD) of percent wetted area across years. 
# - Identification of wetlands where percent wetted area is significantly correlated with MAP.


# List all raster files (these are the RF open water classification rasters)
raster_files <- list.files("G:/Shared drives/ECCC  Ducks Unlimited - Cariboo and Chilcotin/Data/Wetland_100MileHouse_Analysis/RF_Model/Outputs/Single_Date_Analysis", pattern = "\\.tif$", full.names = TRUE)
#6 different rasters

# Load the wetland polygons
wetlands <- st_read("G:/Shared drives/ECCC  Ducks Unlimited - Cariboo and Chilcotin/Data/Study_Area/Wetlands_Merged/Wetlands_All_Merged_Dissolved_32610_select_RF_SUM_intersect.shp")
#91 wetlands

#extract the wetted area for each wetland.
# NOTE: I did a separate analysis and determined 25% is the best threshold for open water - see other R file 2025-04-11_OW-Threshold_analysis_Final
# Create an empty list to store results
wetland_changes <- list()

for (file in raster_files) {
  # Load the raster
  r <- rast(file)
  
  # Extract the date from the filename (assuming format "S2_YYYY_MM_DD.tif")
  date <- gsub(".*_(\\d{4}_\\d{2}_\\d{2})\\.tif$", "\\1", basename(file))
  
  # Mask raster with wetland polygons
  r_masked <- mask(r, vect(wetlands))
  
  # Convert probability raster to binary (threshold at 0.25, modify if needed)
  r_binary <- r_masked > 0.25
  
  # Compute the area of water inside each polygon
  area_wet <- exactextractr::exact_extract(r_binary, wetlands, 'sum') # Count wet pixels
  total_area <- exactextractr::exact_extract(r_binary, wetlands, 'count') # Total pixels
  
  # Calculate percentage of wetted area
  wetlands$wet_percentage <- (area_wet / total_area) * 100
  
  # Store results
  wetland_changes[[date]] <- wetlands %>% st_drop_geometry() %>% mutate(date = date)
}

# Combine results into a single data frame
wetland_time_series <- bind_rows(wetland_changes)

# Extract year from the date column
df <- wetland_time_series

df <- df %>%
  mutate(Year = str_sub(date, 1, 4))  # Extracts "YYYY" from "YYYY_MM_DD"

ggplot(df, aes(x = as.numeric(Year), y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +  
  geom_point() +  # Optional: Add points to emphasize data
  theme_minimal() +
  labs(title = "Change in Wet Percentage Over Time",
       x = "Year",
       y = "Wet Percentage (%)",
       color = "Wetland ID") +
  theme(legend.position = "none")  # Hide legend if too many wetlands

#it is confusing and interesting to visualize all these wetlands on one graph
#You can see common spikes or dips that occur for multiple wetlands for a specific date.
#let's use statistical analysis to better understand what is going on here. SD can help identify consistency (less variation)
# Now you can flag wetlands with low variability in open water percentage
# Let's say you define "consistent" as wetlands where sd < a certain threshold (e.g., sd < 5)
#I experimented with SD2, SD5 and SD10
df_summary <- df %>%
  group_by(ID) %>%
  summarise(
    sd_open_water = sd(wet_percentage),  # Calculate standard deviation
    mean_open_water = mean(wet_percentage)  # Optional: Calculate mean
  )

# Categorize wetlands into variability groups
df_summary <- df_summary %>%
  mutate(
    variability_category = case_when(
      sd_open_water < 2  ~ "Consistent_SD2",
      sd_open_water < 5  ~ "Consistent_SD5",
      sd_open_water < 10 ~ "Consistent_SD10",
      TRUE               ~ "Variable"
    )
  )

# Merge categories back to the main dataframe
df <- df %>%
  left_join(df_summary, by = "ID")

df_bu <- df
df <- df_bu

# Check the distribution of categories
table(df$variability_category)
#Consistent_SD10  Consistent_SD2  Consistent_SD5        Variable 
#90              78             120             258
ggplot(df, aes(x = as.numeric(Year), y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +  
  geom_point() +  
  facet_wrap(~ variability_category) +  # Facet by variability type
  theme_minimal() +
  labs(title = "Change in Wet % Over Time by Variability Category",
       x = "Year",
       y = "Wet Percentage (%)",
       color = "Wetland ID") +
  theme(legend.position = "none")  # Hide legend if too many wetlands


#Plot the wetlands that are just variable
variable_wetlands <- df %>%
  filter(consistency_flag == "Variable")

ggplot(variable_wetlands, aes(x = as.numeric(Year), y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +  
  geom_point() +  # Optional: Add points to emphasize data
  theme_minimal() +
  labs(title = "Change in Wet % Over Time - Variable >SD10",
       x = "Year",
       y = "Wet Percentage (%)",
       color = "Wetland ID")

#you can really start to see which wetlands go up and down. you can also see there are general trends amongst the wetlands

#Merge consistency flag with wetlands polygons based on ID so i can export

# Join the data
update_wetland_polygons_variability <- wetlands %>%
  left_join(df_summary, by = "ID")

st_write(update_wetland_polygons_variability, "G:/Shared drives/ECCC  Ducks Unlimited - Cariboo and Chilcotin/Data/Wetland_100MileHouse_Analysis/Open_water_consistency_analysis/Outputs/wetlands_variability_SD2_SD5_SD10_2025-03-30.shp", append = FALSE)


#We can group wetlands by size as well - I added a size category to my wetlands attribute table in QGIS
#but I also have code in R for this. See bottom of this code file.
#Classes were provided by DUC - Kyla Bass
#ha   wetland size class  m2
#0-1   1      0-10,000
#1-2   2      10,000 - 20,000
#2-3   3      20,000 - 30,000
#3-5   4      30,000 - 50,000
#5-10   5     50,000 - 100,000
#10-20   6    100,000 - 200,000
#20-50   7    200,000 - 500,000
#50+   8      500,000 +

#now I can plot wetlands by size class, for e.g. I want to just plot wetlands of 5-10ha:
sizeclass5 <- df %>%
  filter(Size_Class == "5")
ggplot(sizeclass5, aes(x = date, y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +
  labs(title = "Size Class 5", x = "Date", y = "Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


sizeclass4 <- df %>%
  filter(Size_Class == "4")
ggplot(sizeclass4, aes(x = date, y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +
  labs(title = "Size Class 4", x = "Date", y = "Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


sizeclass3 <- df %>%
  filter(Size_Class == "3")
ggplot(sizeclass3, aes(x = date, y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +
  labs(title = "Size Class 3", x = "Date", y = "Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


sizeclass2 <- df %>%
  filter(Size_Class == "2")
ggplot(sizeclass2, aes(x = date, y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +
  labs(title = "Size Class 2", x = "Date", y = "Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


sizeclass1 <- df %>%
  filter(Size_Class == "1")
ggplot(sizeclass1, aes(x = date, y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +
  labs(title = "Size Class 1", x = "Date", y = "Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


sizeclass6 <- df %>%
  filter(Size_Class == "6")
ggplot(sizeclass6, aes(x = date, y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +
  labs(title = "Size Class 6", x = "Date", y = "Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


sizeclass7 <- df %>%
  filter(Size_Class == "7")
ggplot(sizeclass7, aes(x = date, y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +
  labs(title = "Size Class 7", x = "Date", y = "Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 


sizeclass8 <- df %>%
  filter(Size_Class == "8")
ggplot(sizeclass8, aes(x = date, y = wet_percentage, group = ID, color = as.factor(ID))) +
  geom_line() +
  labs(title = "Size Class 8", x = "Date", y = "Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 



#You can visualize just one specific wetland by its fid #
# Filter for the specific wetland (fid = 520643)
df_wetland_520643 <- df_variability_summer %>%
  filter(fid == 520643)

# Plot for the specific wetland
ggplot(df_wetland_520643, aes(x = summer_start, y = median_wet_percentage, group = fid, color = as.factor(fid))) +
  geom_line() +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +  # Show years on x-axis
  labs(title = "Median Wetted Area for Wetland fid 520643 (Summers Only)", 
       x = "Year", 
       y = "Median Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))





#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CLIMATE DATA ANALYSIS@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# now climate data...
# I think I am most interested in precipitation and maybe flow rates
# MODEL THE RELATIONSHIP B/W MAP AND WET PERCENTAGE:
########################################
#####################################
################################

#test an individual wetland
wetland_160 <- df %>%
  filter(ID == 160)

head(wetland_160)

#plt wet_percentage against Year with a line connecting the points
ggplot(wetland_160, aes(x = Year, y = wet_percentage, group = 1)) +  # Ensure the points are grouped together
  geom_line(color = "blue", size = 1) +  # Line connecting the points
  geom_point(color = "red", size = 3) +   # Points on the line
  labs(
    title = "Wetland Wetted Area Over Time",
    x = "Year",
    y = "Wetted Area (%)"
  ) +
  theme_minimal()

climate_data <- read.csv("G:/Shared drives/ECCC  Ducks Unlimited - Cariboo and Chilcotin/Data/ClimateBC/Analysis_of_trends/Climate_Data_For_R.csv")
# Convert X.period to Year by extracting the numeric part
climate_data <- climate_data %>%
  mutate(Year = as.numeric(str_extract(X.period, "[0-9]+"))) %>%  # Extracts 2019, 2020, etc.
  select(Year,MAP)  # Keep only relevant columns

# Select relevant columns from wetland_#
wetland_data_selected <- wetland_160 %>%
  select(Year, wet_percentage)

# Merge discharge and wetland data
merged_data <- merge(climate_data, wetland_data_selected, by = "Year", all = TRUE)

# Reshape data for ggplot
long_data <- merged_data %>%
  pivot_longer(cols = c(wet_percentage, MAP), 
               names_to = "Variable", 
               values_to = "Value")

#drop 2024 bc no climate data
long_data <- long_data %>% filter(Year != 2024)

#could have done this for merged_data too
#merged_data_clean <- merged_data %>% filter(Year !=2024)

ggplot(long_data, aes(x = Year, y = Value, color = Variable, group = Variable)) +
  geom_line(size = 1) +  # Add lines
  geom_point(size = 3) + # Add points
  scale_color_manual(values = c("wet_percentage" = "blue", "MAP" = "red")) +
  labs(title = "Wet Percentage and MAP Over Years",
       x = "Year",
       y = "Value",
       color = "Variable") +
  theme_minimal()

#dual y-axis

# Get min/max values for scaling MAP
min_MAP <- min(long_data$Value[long_data$Variable == "MAP"])
max_MAP <- max(long_data$Value[long_data$Variable == "MAP"])
min_wet <- min(long_data$Value[long_data$Variable == "wet_percentage"])
max_wet <- max(long_data$Value[long_data$Variable == "wet_percentage"])

# Rescale MAP to match wet_percentage range
long_data_scaled <- long_data %>%
  mutate(Value_scaled = ifelse(
    Variable == "MAP",
    (Value - min_MAP) / (max_MAP - min_MAP) * (max_wet - min_wet) + min_wet,
    Value
  ))

# Plot with dual y-axis
ggplot(long_data_scaled, aes(x = Year)) +
  geom_line(data = long_data_scaled %>% filter(Variable == "wet_percentage"), 
            aes(y = Value, color = "wet_percentage", group = 1), size = 1) +  # Line for wet_percentage
  geom_point(data = long_data_scaled %>% filter(Variable == "wet_percentage"), 
             aes(y = Value, color = "wet_percentage"), size = 3) +  # Points for wet_percentage
  geom_line(data = long_data_scaled %>% filter(Variable == "MAP"), 
            aes(y = Value_scaled, color = "MAP", group = 2), size = 1, linetype = "dashed") +  # Line for MAP
  geom_point(data = long_data_scaled %>% filter(Variable == "MAP"), 
             aes(y = Value_scaled, color = "MAP"), size = 3) +  # Points for MAP
  scale_y_continuous(
    name = "Wet Percentage",
    sec.axis = sec_axis(~ (. - min_wet) * (max_MAP - min_MAP) / (max_wet - min_wet) + min_MAP, 
                        name = "MAP")
  ) +
  scale_color_manual(values = c("wet_percentage" = "blue", "MAP" = "red")) +
  labs(title = "Wet Percentage and MAP Over Time",
       x = "Year",
       color = "Variable") +
  theme_minimal()


#IS THERE CORRELATION?
cor(merged_data_clean$MAP, merged_data_clean$wet_percentage)
#0.90

#If the value is close to 1, there is a strong positive correlation.
#If the value is close to -1, there is a strong negative correlation.
#If the value is close to 0, there is no linear relationship.

#but is that just for a linear relationship?
ggplot(merged_data_clean, aes(x = MAP, y = wet_percentage)) +
  geom_point(color = "blue", size = 3) +  # Scatter plot points
  geom_smooth(method = "lm", color = "red", se = TRUE) +  # Regression line with confidence interval
  labs(title = "Relationship between MAP and Wet Percentage",
       x = "Mean Annual Precipitation (MAP)",
       y = "Wet Percentage") +
  theme_minimal()



# how do I determine correlation for all 91 wetlands?
# I have wetlands data, each wetland has a unique ID "ID" and a value for wet_percentage for each year 2019-2023. I also have values for MAP for each year. 
# How do I test each wetland to determine if there is a correlation between MAP values and wet_percentage across the years?  I want to add this as a new column "Correlated_to_precipitation" = Y/N if that value is significant
# Group by ID (each wetland).
# 
# Calculate the Pearson correlation between MAP and wet_percentage for each wetland.
# 
# Perform a significance test (cor.test()).
# 
# Store results in a new column: "Correlated_to_precipitation" = "Y" if significant (p-value < 0.05), "N" otherwise.
wetlands_df <- df

# Convert Year to numeric in wetlands_df
wetlands_df <- wetlands_df %>%
  mutate(Year = as.numeric(Year))

# Convert Year to numeric in climate_data
climate_data <- climate_data %>%
  mutate(Year = as.numeric(Year))

# Now perform the join
wetlands_df <- wetlands_df %>%
  left_join(climate_data, by = "Year")

#drop year 2024 since no MAP data - though I'm sure I can find this somewhere
#drop 2024 bc no climate data
wetlands_df <- wetlands_df %>% filter(Year != 2024)

#select columns of interest
wetlands_df <- wetlands_df %>%
  select(ID, Year, wet_percentage, MAP)


#KEY INFORMATION:
#associate correlation value with each unique wetland ID in a new dataframe.
#how do I do this?

# Function to compute correlation for each wetland
compute_correlation <- function(wetland_data) {
  cor_value <- cor(wetland_data$MAP, wetland_data$wet_percentage, use = "complete.obs")  
  return(cor_value)
}

# Apply function to each wetland ID
correlation_results <- wetlands_df %>%
  group_by(ID) %>%
  summarise(correlation = compute_correlation(cur_data()))

# View the resulting dataframe
print(correlation_results)

#check it:

wetland_177 <- wetlands_df %>%
  filter(ID == 177)

#and determine: IS THERE CORRELATION?
cor(wetland_177$MAP, wetland_177$wet_percentage)
#0.812 --> CORRECT

#but is that just for a linear relationship?
ggplot(wetland_143, aes(x = MAP, y = wet_percentage)) +
  geom_point(color = "blue", size = 3) +  # Scatter plot points
  geom_smooth(method = "lm", color = "red", se = TRUE) +  # Regression line with confidence interval
  labs(title = "Relationship between MAP and Wet Percentage",
       x = "Mean Annual Precipitation (MAP)",
       y = "Wet Percentage") +
  theme_minimal()

# Join the data
update_wetland_polygons_variability_correlation <- update_wetland_polygons_variability %>%
  left_join(correlation_results, by = "ID")

st_write(update_wetland_polygons_variability_correlation, "G:/Shared drives/ECCC  Ducks Unlimited - Cariboo and Chilcotin/Data/Wetland_100MileHouse_Analysis/Open_water_consistency_analysis/Outputs/wetlands_variability_correlation_2025-04-02.shp", append = FALSE)

#key information END

#so that worked well, but now I want to get teh p-value

# Function to compute correlation and p-value
compute_correlation <- function(wetland_data) {
  test_result <- cor.test(wetland_data$MAP, wetland_data$wet_percentage, use = "complete.obs")  
  return(data.frame(correlation = test_result$estimate, 
                    p_value = test_result$p.value))
}

# Apply function to each wetland ID
correlation_results <- wetlands_df %>%
  group_by(ID) %>%
  summarise(correlation = compute_correlation(cur_data())$correlation,
            p_value = compute_correlation(cur_data())$p_value) %>%
  mutate(precip_significant = ifelse(p_value < 0.05, "Y", "N"))

# View results
print(correlation_results)


update_wetland_polygons_precip_signficant <- update_wetland_polygons_variability %>%
  left_join(correlation_results, by = "ID")

st_write(update_wetland_polygons_precip_signficant, "G:/Shared drives/ECCC  Ducks Unlimited - Cariboo and Chilcotin/Data/Wetland_100MileHouse_Analysis/Open_water_consistency_analysis/Outputs/wetlands_precip_significant_2025-04-02.shp", append = FALSE)






#it would be interesting to compare within one year how much these change over a season...
#even just from the image dates we have. Like in 2021. But it was pretty smokey
#it looks like the imagery is not lining up perfectly between dates too... 





#CODE FOR ADDING AND GROUPING WETLANDS BY SIZE
#We will want to group wetlands by size as well.

#Group by areas - these classes were provided by DUC - Kyla Bass
#ha   wetland size class  m2
#0-1   1      0-10,000
#1-2   2      10,000 - 20,000
#2-3   3      20,000 - 30,000
#3-5   4      30,000 - 50,000
#5-10   5     50,000 - 100,000
#10-20   6    100,000 - 200,000
#20-50   7    200,000 - 500,000
#50+   8      500,000 +

# Add wetland size class based on Area (m²)
df <- df %>%
  mutate(
    wetland_size_class = case_when(
      Area >= 0 & Area < 10000 ~ 1,         # 0–1 ha
      Area >= 10000 & Area < 20000 ~ 2,     # 1–2 ha
      Area >= 20000 & Area < 30000 ~ 3,     # 2–3 ha
      Area >= 30000 & Area < 50000 ~ 4,     # 3–5 ha
      Area >= 50000 & Area < 100000 ~ 5,    # 5–10 ha
      Area >= 100000 & Area < 200000 ~ 6,   # 10–20 ha
      Area >= 200000 & Area < 500000 ~ 7,   # 20–50 ha
      Area >= 500000 ~ 8                    # 50+ ha
    )
  )

# Count the number of entries in each size class... remember there are multiple dates per wetlands 
#so the number of wetlands is these numbers / 29
class_counts <- df %>%
  count(fid)

print(class_counts) 
#28

class_counts <- df %>%
  count(wetland_size_class)

# View the results
print(class_counts)
#wetland_size_class    n    divided by 28 (manually)
#1                  1 1428 #51
#2                  2  140 #5
#3                  3  140 #5
#4                  4  112 #4
#5                  5  112 #4
#6                  6   84 #3
#7                  7   84 #3
#8                  8   56 #2

#now I can plot wetlands by size class, for e.g. I want to just plot wetlands of 5-10ha:
sizeclass5 <- df %>%
  filter(wetland_size_class == "5")

ggplot(sizeclass5, aes(x = date, y = wet_percentage, group = fid, color = as.factor(fid))) +
  geom_line() +
  labs(title = "Wetted Area Change Over Time", x = "Date", y = "Percentage Wetted Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
